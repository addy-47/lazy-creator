common cmds
cd .\lazy-creator\frontend; npm run dev
cd .\lazy-creator\backend\app; python main.py
cd .\lazy-creator;mongod --dbpath "E:\MongoDBData"

# Lazy Creator App Deployment Roadmap

# PART 1: GCP CLOUD DEPLOYMENT

## Overview
- Backend: Python Flask API → Google Cloud Run
- Frontend: React SPA → Google Cloud Run (instead of App Engine)
- Database: MongoDB → MongoDB Atlas with VPC peering to GCP
- Domain: lazycreator.in (GoDaddy)

## 1. Prerequisites and External Setups Before Code Changes

### GCP Setup
- GCP Account set up with billing enabled
- gcloud CLI installed and configured
- Docker installed locally
- GitHub/GitLab repository for CI/CD (optional)

### Service Account Permissions
The existing service account with these permissions is sufficient:
- roles/cloudbuild.builds.builder
- roles/containerregistry.ServiceAgent
- roles/iam.serviceAccountUser
- roles/logging.logWriter
- roles/monitoring.metricWriter
- roles/run.admin
- roles/secretmanager.admin
- roles/storage.admin

### Domain Setup in GoDaddy
1. Login to GoDaddy account
2. Navigate to lazycreator.in DNS settings
3. Add the following DNS records:
   - A record: @ → will point to GCP load balancer IP (to be obtained later)
   - CNAME record: www → lazycreator.in
   - TXT record: @ → value provided by Google domain verification (to be obtained)

### Database Setup (MongoDB Atlas)
1. Create MongoDB Atlas account
2. Create a new project and deploy a MongoDB cluster (M10 or higher for production)
3. Configure network access:
   - Whitelist GCP IP ranges
   - Set up VPC peering between MongoDB Atlas and your GCP project
4. Create database user with proper access rights
5. Obtain MongoDB connection string (has been added to the .env file)

## 2. Code Changes for Production

The following code changes have been made for production deployment:

### Backend Changes:
1. Updated CORS configurations to handle production domains
2. Enhanced storage_helper.py to better support Cloud Run environment
3. Updated Dockerfile for production deployment
4. Added proper environment variable handling

### Frontend Changes:
1. Created Dockerfile for building and serving the frontend
2. Created Nginx configuration for serving the SPA
3. Updated API URL configuration to switch between dev and prod environments

## 3. Deployment Steps

### Step 1: Build and Deploy Backend

First, build and deploy the backend to Cloud Run:

```bash
# Navigate to backend directory
cd backend

# Build the Docker image
gcloud builds submit --tag gcr.io/[PROJECT_ID]/lazy-creator-backend

# Deploy to Cloud Run
gcloud run deploy backend \
  --image gcr.io/[PROJECT_ID]/lazy-creator-backend \
  --platform managed \
  --allow-unauthenticated \
  --memory 2Gi \
  --cpu 2 \
  --region [REGION] \
  --set-env-vars="DEBUG=False,FRONTEND_URL=https://lazycreator.in" \
  --update-secrets="MONGODB_URI=mongodb-uri:latest,NEWS_API_KEY=news-api-key:latest,PEXELS_API_KEY=pexels-api-key:latest,PIXABAY_API_KEY=pixabay-api-key:latest" \
  --service-account=[SERVICE_ACCOUNT_EMAIL]
```

Once deployed, note the URL of your backend service (e.g., `https://backend-xyz123.run.app`). You'll need this for the frontend deployment.

### Step 2: Create DNS Entry for Backend

Create a DNS record for the backend subdomain:
```bash
# Get the backend URL from Cloud Run
BACKEND_URL=$(gcloud run services describe backend --platform managed --region [REGION] --format="value(status.url)")

# Add a CNAME record in GoDaddy DNS settings:
# backend.lazycreator.in -> [BACKEND_URL] (without https://)
```

### Step 3: Build and Deploy Frontend

Next, build and deploy the frontend to Cloud Run:

```bash
# Navigate to frontend directory
cd frontend

# Build the Docker image
gcloud builds submit --tag gcr.io/[PROJECT_ID]/lazy-creator-frontend

# Deploy to Cloud Run
gcloud run deploy frontend \
  --image gcr.io/[PROJECT_ID]/lazy-creator-frontend \
  --platform managed \
  --allow-unauthenticated \
  --memory 1Gi \
  --region [REGION] \
  --service-account=[SERVICE_ACCOUNT_EMAIL]
```

### Step 4: Set Up Load Balancer and Domain

Follow these steps to set up a global HTTPS load balancer for your domain:

1. Create load balancer:
   ```bash
   gcloud compute addresses create lazy-creator-ip --global
   gcloud compute addresses describe lazy-creator-ip --global --format="get(address)"
   ```

2. Create HTTPS certificate:
   ```bash
   gcloud compute ssl-certificates create lazycreator-cert \
     --domains=lazycreator.in,www.lazycreator.in
   ```

3. Set up HTTPS load balancer with Cloud Run backend:
   ```bash
   # Create backend service for frontend
   gcloud compute backend-services create lazy-creator-frontend \
     --global \
     --load-balancing-scheme=EXTERNAL

   # Create NEG (Network Endpoint Group) for frontend Cloud Run service
   gcloud compute network-endpoint-groups create lazy-creator-frontend-neg \
     --region=[REGION] \
     --network-endpoint-type=SERVERLESS \
     --cloud-run-service=frontend

   # Add the NEG as a backend to the backend service
   gcloud compute backend-services add-backend lazy-creator-frontend \
     --global \
     --network-endpoint-group=lazy-creator-frontend-neg \
     --network-endpoint-group-region=[REGION]

   # Create URL map
   gcloud compute url-maps create lazy-creator-url-map \
     --default-service=lazy-creator-frontend

   # Create path matcher for backend
   gcloud compute url-maps add-path-matcher lazy-creator-url-map \
     --path-matcher-name=backend-paths \
     --default-service=lazy-creator-frontend \
     --path-rules="/api/*=lazy-creator-backend"

   # Create HTTPS proxy
   gcloud compute target-https-proxies create lazy-creator-https-proxy \
     --url-map=lazy-creator-url-map \
     --ssl-certificates=lazycreator-cert

   # Create forwarding rule
   gcloud compute forwarding-rules create lazy-creator-https-rule \
     --global \
     --target-https-proxy=lazy-creator-https-proxy \
     --address=lazy-creator-ip \
     --ports=443
   ```

4. Update GoDaddy DNS with the IP address obtained from step 1

### Step 5: Verify Deployment

1. Test the application via the domain name:
   ```
   https://lazycreator.in
   ```

2. Verify API access:
   ```
   https://lazycreator.in/api/health
   ```

3. Monitor logs to ensure everything is working properly:
   ```bash
   gcloud logging read "resource.type=cloud_run_revision AND resource.labels.service_name=frontend"
   gcloud logging read "resource.type=cloud_run_revision AND resource.labels.service_name=backend"
   ```

## 4. Monitoring and Maintenance

1. Set up Cloud Monitoring:
   ```
   gcloud monitoring dashboards create --config-from-file=dashboard.json
   ```

2. Configure alerts for backend errors:
   ```
   gcloud alpha monitoring channels create --display-name="Email Alerts" --type=email --email-address=you@example.com
   ```

3. Set up budget alerts:
   ```
   gcloud billing budgets create --billing-account=[BILLING_ACCOUNT_ID] \
     --display-name="Monthly Budget" \
     --budget-amount=500 \
     --threshold-rule=percent=80,basis=current-spend
   ```

### Important Notes for Production Deployment:

1. **Environment Variables**: Ensure all sensitive values are stored in Secret Manager instead of directly in environment variables.

2. **Domain Propagation**: DNS changes can take 24-48 hours to fully propagate.

3. **SSL Certificate**: The certificate might take some time to provision, especially if using a managed certificate.

4. **MongoDB Access**: Ensure your MongoDB Atlas cluster allows access from your GCP VPC and Cloud Run services.

5. **Recovery Plan**: Have a backup and recovery plan in place before switching to production.

# PART 2: MOBILE APP DEPLOYMENT (FUTURE)

## Overview
- Mobile Framework: React Native
- Distribution: Google Play Store and Apple App Store
- Backend: Same GCP Cloud Run backend used by web app
- Authentication: OAuth 2.0 with Google, Apple, and email/password

## 1. Prerequisites and External Setups Before Code Changes

### Development Environment
- Install Node.js and npm/yarn
- Setup React Native development environment:
  - Install Android Studio for Android development
  - Install Xcode for iOS development (requires macOS)
  - Setup Java Development Kit (JDK)

### External Account Setup
1. Google Play Developer Account ($25 one-time fee)
2. Apple Developer Account ($99/year)
3. Firebase Project (for authentication, analytics, and crash reporting)
4. App Store Connect account (iOS)

### Certificates and Keys
1. Android:
   - Generate keystore file for signing Android APK
   - Register app in Google Play Console
   - Set up Google Play App Signing

2. iOS:
   - Generate App Store certificates from Apple Developer account
   - Create App ID in Apple Developer account
   - Set up provisioning profiles

## 2. Mobile App Code Implementation

### Core Requirements
1. React Native project with TypeScript
2. Authentication with Firebase
3. Integration with backend API
4. Offline capabilities
5. Push notification support

### Project Setup
```
npx react-native init LazyCreatorApp --template react-native-template-typescript
cd LazyCreatorApp
npm install @react-navigation/native @react-navigation/stack
npm install react-native-reanimated react-native-gesture-handler
npm install firebase @react-native-firebase/app @react-native-firebase/auth
npm install @react-native-async-storage/async-storage
npm install react-native-dotenv
npm install @react-native-community/netinfo
```

### Environment Configuration
Create `.env.development` and `.env.production` files:
```
# .env.development
API_URL=http://localhost:5000/api

# .env.production
API_URL=https://backend.lazycreator.in/api
```

### API Integration
```typescript
// api.ts
import { API_URL } from '@env';

interface APIOptions {
  endpoint: string;
  method?: string;
  data?: any;
  token?: string;
}

export async function callAPI({ endpoint, method = 'GET', data, token }: APIOptions) {
  const headers: HeadersInit = {
    'Content-Type': 'application/json'
  };

  if (token) {
    headers['Authorization'] = `Bearer ${token}`;
  }

  const config: RequestInit = {
    method,
    headers,
    body: data ? JSON.stringify(data) : undefined
  };

  const response = await fetch(`${API_URL}/${endpoint}`, config);

  if (!response.ok) {
    throw new Error(`API error: ${response.status}`);
  }

  return response.json();
}
```

### Offline Support
```typescript
// offlineManager.ts
import AsyncStorage from '@react-native-async-storage/async-storage';
import NetInfo from '@react-native-community/netinfo';

const PENDING_ACTIONS_KEY = 'PENDING_API_ACTIONS';

interface PendingAction {
  id: string;
  endpoint: string;
  method: string;
  data: any;
  timestamp: number;
}

export async function savePendingAction(action: Omit<PendingAction, 'id' | 'timestamp'>) {
  const pendingActionsString = await AsyncStorage.getItem(PENDING_ACTIONS_KEY);
  const pendingActions = pendingActionsString ? JSON.parse(pendingActionsString) : [];

  const newAction: PendingAction = {
    ...action,
    id: Date.now().toString(),
    timestamp: Date.now()
  };

  pendingActions.push(newAction);
  await AsyncStorage.setItem(PENDING_ACTIONS_KEY, JSON.stringify(pendingActions));
}

export async function processPendingActions(apiCallFunction: Function) {
  const isConnected = await NetInfo.fetch().then(state => state.isConnected);

  if (!isConnected) return;

  const pendingActionsString = await AsyncStorage.getItem(PENDING_ACTIONS_KEY);
  if (!pendingActionsString) return;

  const pendingActions: PendingAction[] = JSON.parse(pendingActionsString);
  const failedActions: PendingAction[] = [];

  for (const action of pendingActions) {
    try {
      await apiCallFunction({
        endpoint: action.endpoint,
        method: action.method,
        data: action.data
      });
    } catch (error) {
      failedActions.push(action);
    }
  }

  await AsyncStorage.setItem(PENDING_ACTIONS_KEY, JSON.stringify(failedActions));
}
```

## 3. Preparing for App Store Deployment

### Android Preparation
1. Create app icon assets
2. Update `android/app/build.gradle` with app version
3. Create signing configuration in gradle
4. Generate signed APK/AAB:
   ```
   cd android
   ./gradlew bundleRelease
   ```

### iOS Preparation
1. Create app icon and launch screen
2. Configure `info.plist` with necessary permissions
3. Set version and build number in Xcode
4. Archive app for distribution:
   - Open project in Xcode
   - Select Generic iOS Device as build target
   - Select Product > Archive

## 4. Publishing to App Stores

### Google Play Store
1. Create Store Listing:
   - App name, description, and promo text
   - Screenshots (phone, tablet)
   - Feature graphic and promo video (optional)

2. Upload AAB (Android App Bundle):
   ```
   cd android && ./gradlew bundleRelease
   ```

3. Set up pricing and distribution
4. Complete content rating questionnaire
5. Set up Internal/Alpha/Beta testing tracks before production release

### Apple App Store
1. Create App Store listing in App Store Connect:
   - App name, description, keywords
   - Screenshots for various device sizes
   - App preview videos (optional)

2. Upload build through Xcode or Application Loader
3. Configure pricing and availability
4. Complete app review information
5. Submit for App Review

## 5. Post-Launch Maintenance
1. Monitor crash reports and user feedback
2. Plan regular updates (feature, maintenance, security)
3. A/B testing for new features
4. Push notification campaigns
5. Analytics tracking to improve user experience


Future Updates:
1. add payment Integration with freemium plans
2. the utimate sloth mode (auto everything)
3. improve custom_maker
